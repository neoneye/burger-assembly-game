<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BURGER ASSEMBLY - C64 Style</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
canvas { image-rendering: pixelated; image-rendering: crisp-edges; cursor: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// ============================================================
// BURGER ASSEMBLY - A C64-Style Game
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// Virtual resolution (C64-ish)
const W = 320;
const H = 200;
let scale = 1;

function resize() {
  const sx = window.innerWidth / W;
  const sy = window.innerHeight / H;
  scale = Math.floor(Math.min(sx, sy));
  if (scale < 1) scale = 1;
  canvas.width = W * scale;
  canvas.height = H * scale;
  ctx.imageSmoothingEnabled = false;
}
resize();
window.addEventListener('resize', resize);

// C64 Color Palette
const C64 = {
  black:      '#000000',
  white:      '#FFFFFF',
  red:        '#880000',
  cyan:       '#AAFFEE',
  purple:     '#CC44CC',
  green:      '#00CC55',
  blue:       '#0000AA',
  yellow:     '#EEEE77',
  orange:     '#DD8855',
  brown:      '#664400',
  lightRed:   '#FF7777',
  darkGrey:   '#333333',
  grey:       '#777777',
  lightGreen: '#AAFF66',
  lightBlue:  '#0088FF',
  lightGrey:  '#BBBBBB',
};

// ============================================================
// C64-STYLE BITMAP FONT (4x5 glyphs, uppercase + digits + punctuation)
// ============================================================
const FONT_W = 4;
const FONT_H = 5;

const GLYPH_DATA = {
  'A': [0b0110,0b1001,0b1111,0b1001,0b1001],
  'B': [0b1110,0b1001,0b1110,0b1001,0b1110],
  'C': [0b0111,0b1000,0b1000,0b1000,0b0111],
  'D': [0b1110,0b1001,0b1001,0b1001,0b1110],
  'E': [0b1111,0b1000,0b1110,0b1000,0b1111],
  'F': [0b1111,0b1000,0b1110,0b1000,0b1000],
  'G': [0b0111,0b1000,0b1011,0b1001,0b0111],
  'H': [0b1001,0b1001,0b1111,0b1001,0b1001],
  'I': [0b1110,0b0100,0b0100,0b0100,0b1110],
  'J': [0b0111,0b0010,0b0010,0b1010,0b0100],
  'K': [0b1001,0b1010,0b1100,0b1010,0b1001],
  'L': [0b1000,0b1000,0b1000,0b1000,0b1111],
  'M': [0b1001,0b1111,0b1111,0b1001,0b1001],
  'N': [0b1001,0b1101,0b1111,0b1011,0b1001],
  'O': [0b0110,0b1001,0b1001,0b1001,0b0110],
  'P': [0b1110,0b1001,0b1110,0b1000,0b1000],
  'Q': [0b0110,0b1001,0b1001,0b1011,0b0111],
  'R': [0b1110,0b1001,0b1110,0b1010,0b1001],
  'S': [0b0111,0b1000,0b0110,0b0001,0b1110],
  'T': [0b1111,0b0100,0b0100,0b0100,0b0100],
  'U': [0b1001,0b1001,0b1001,0b1001,0b0110],
  'V': [0b1001,0b1001,0b1001,0b0110,0b0110],
  'W': [0b1001,0b1001,0b1111,0b1111,0b1001],
  'X': [0b1001,0b1001,0b0110,0b1001,0b1001],
  'Y': [0b1001,0b1001,0b0110,0b0100,0b0100],
  'Z': [0b1111,0b0001,0b0110,0b1000,0b1111],
  '0': [0b0110,0b1011,0b1101,0b1001,0b0110],
  '1': [0b0100,0b1100,0b0100,0b0100,0b1110],
  '2': [0b0110,0b1001,0b0010,0b0100,0b1111],
  '3': [0b1110,0b0001,0b0110,0b0001,0b1110],
  '4': [0b1001,0b1001,0b1111,0b0001,0b0001],
  '5': [0b1111,0b1000,0b1110,0b0001,0b1110],
  '6': [0b0111,0b1000,0b1110,0b1001,0b0110],
  '7': [0b1111,0b0001,0b0010,0b0100,0b0100],
  '8': [0b0110,0b1001,0b0110,0b1001,0b0110],
  '9': [0b0110,0b1001,0b0111,0b0001,0b1110],
  '!': [0b0100,0b0100,0b0100,0b0000,0b0100],
  '?': [0b0110,0b1001,0b0010,0b0000,0b0010],
  '.': [0b0000,0b0000,0b0000,0b0000,0b0100],
  ',': [0b0000,0b0000,0b0000,0b0100,0b1000],
  ':': [0b0000,0b0100,0b0000,0b0100,0b0000],
  '-': [0b0000,0b0000,0b1111,0b0000,0b0000],
  '+': [0b0000,0b0100,0b1110,0b0100,0b0000],
  '/': [0b0001,0b0010,0b0100,0b1000,0b0000],
  '\'': [0b0100,0b0100,0b0000,0b0000,0b0000],
  '"': [0b1010,0b1010,0b0000,0b0000,0b0000],
  '(': [0b0010,0b0100,0b0100,0b0100,0b0010],
  ')': [0b0100,0b0010,0b0010,0b0010,0b0100],
  '#': [0b1010,0b1111,0b1010,0b1111,0b1010],
  '*': [0b1001,0b0110,0b1111,0b0110,0b1001],
  ' ': [0b0000,0b0000,0b0000,0b0000,0b0000],
};

function drawChar(ch, x, y, color, sz) {
  const g = GLYPH_DATA[ch];
  if (!g) return;
  ctx.fillStyle = color;
  for (let row = 0; row < FONT_H; row++) {
    for (let col = 0; col < FONT_W; col++) {
      if (g[row] & (1 << (FONT_W - 1 - col))) {
        ctx.fillRect((x + col * sz) * scale, (y + row * sz) * scale, sz * scale, sz * scale);
      }
    }
  }
}

function drawText(str, x, y, color, sz = 1) {
  const spacing = (FONT_W + 1) * sz;
  for (let i = 0; i < str.length; i++) {
    drawChar(str[i].toUpperCase(), x + i * spacing, y, color, sz);
  }
}

function textWidth(str, sz = 1) {
  return str.length * (FONT_W + 1) * sz - sz;
}

function drawTextCentered(str, y, color, sz = 1) {
  const w = textWidth(str, sz);
  drawText(str, Math.floor((W - w) / 2), y, color, sz);
}

// ============================================================
// AUDIO ENGINE (SID-ish bleeps and bloops)
// ============================================================
let audioCtx = null;

function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

function playTone(freq, duration, type = 'square', vol = 0.15) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function sfxCatch()   { playTone(523, 0.08); playTone(659, 0.08); setTimeout(() => playTone(784, 0.1), 60); }
function sfxDrop()    { playTone(200, 0.3, 'sawtooth', 0.1); }
function sfxComplete(){ playTone(523,0.1); setTimeout(()=>playTone(659,0.1),100); setTimeout(()=>playTone(784,0.1),200); setTimeout(()=>playTone(1047,0.2),300); }
function sfxWrong()   { playTone(150, 0.2, 'sawtooth', 0.12); setTimeout(() => playTone(120, 0.3, 'sawtooth', 0.1), 150); }
function sfxGameOver(){ playTone(400,0.2,'sawtooth',0.1); setTimeout(()=>playTone(300,0.2,'sawtooth',0.1),200); setTimeout(()=>playTone(200,0.4,'sawtooth',0.1),400); }
function sfxSelect()  { playTone(880, 0.06); }
function sfxStart()   { playTone(440,0.1); setTimeout(()=>playTone(554,0.1),80); setTimeout(()=>playTone(659,0.1),160); setTimeout(()=>playTone(880,0.15),240); }
function sfxLevelUp() { for(let i=0;i<6;i++) setTimeout(()=>playTone(440+i*110,0.08),i*60); }

// ============================================================
// INGREDIENT DEFINITIONS
// ============================================================
const INGREDIENTS = [
  { name: 'BOTTOM BUN', key: 'bottom_bun' },
  { name: 'PATTY',      key: 'patty' },
  { name: 'CHEESE',     key: 'cheese' },
  { name: 'LETTUCE',    key: 'lettuce' },
  { name: 'TOMATO',     key: 'tomato' },
  { name: 'ONION',      key: 'onion' },
  { name: 'TOP BUN',    key: 'top_bun' },
];

// Pixel art for each ingredient (drawn at 40x12 virtual pixels)
const ING_W = 40;
const ING_H = 12;

function drawIngredient(key, x, y, pixSize = 1) {
  switch (key) {
    case 'bottom_bun': drawBottomBun(x, y, pixSize); break;
    case 'patty':      drawPatty(x, y, pixSize); break;
    case 'cheese':     drawCheese(x, y, pixSize); break;
    case 'lettuce':    drawLettuce(x, y, pixSize); break;
    case 'tomato':     drawTomato(x, y, pixSize); break;
    case 'onion':      drawOnion(x, y, pixSize); break;
    case 'top_bun':    drawTopBun(x, y, pixSize); break;
  }
}

function px(x, y, w, h, color, ps) {
  ctx.fillStyle = color;
  ctx.fillRect(x * scale, y * scale, w * ps * scale, h * ps * scale);
}

function drawBottomBun(ox, oy, ps) {
  // Flat bottom bun - golden brown
  ctx.fillStyle = C64.orange;
  ctx.fillRect((ox + 4*ps) * scale, oy * scale, 32*ps * scale, 4*ps * scale);
  ctx.fillStyle = C64.brown;
  ctx.fillRect((ox + 2*ps) * scale, (oy + 4*ps) * scale, 36*ps * scale, 4*ps * scale);
  ctx.fillStyle = C64.orange;
  ctx.fillRect((ox + 6*ps) * scale, (oy + 2*ps) * scale, 6*ps * scale, 2*ps * scale);
  ctx.fillRect((ox + 20*ps) * scale, (oy + 2*ps) * scale, 4*ps * scale, 2*ps * scale);
}

function drawTopBun(ox, oy, ps) {
  // Rounded top bun with sesame seeds
  ctx.fillStyle = C64.orange;
  ctx.fillRect((ox + 6*ps) * scale, oy * scale, 28*ps * scale, 2*ps * scale);
  ctx.fillRect((ox + 4*ps) * scale, (oy + 2*ps) * scale, 32*ps * scale, 3*ps * scale);
  ctx.fillStyle = C64.brown;
  ctx.fillRect((ox + 2*ps) * scale, (oy + 5*ps) * scale, 36*ps * scale, 3*ps * scale);
  // Sesame seeds
  ctx.fillStyle = C64.yellow;
  ctx.fillRect((ox + 10*ps) * scale, (oy + 1*ps) * scale, 3*ps * scale, 1*ps * scale);
  ctx.fillRect((ox + 18*ps) * scale, (oy + 0*ps) * scale, 3*ps * scale, 1*ps * scale);
  ctx.fillRect((ox + 26*ps) * scale, (oy + 1*ps) * scale, 3*ps * scale, 1*ps * scale);
}

function drawPatty(ox, oy, ps) {
  ctx.fillStyle = C64.brown;
  ctx.fillRect((ox + 3*ps) * scale, (oy + 1*ps) * scale, 34*ps * scale, 5*ps * scale);
  ctx.fillStyle = '#552200';
  ctx.fillRect((ox + 5*ps) * scale, (oy + 2*ps) * scale, 30*ps * scale, 3*ps * scale);
  // Grill marks
  ctx.fillStyle = C64.darkGrey;
  ctx.fillRect((ox + 8*ps) * scale, (oy + 3*ps) * scale, 6*ps * scale, 1*ps * scale);
  ctx.fillRect((ox + 18*ps) * scale, (oy + 3*ps) * scale, 6*ps * scale, 1*ps * scale);
  ctx.fillRect((ox + 28*ps) * scale, (oy + 3*ps) * scale, 4*ps * scale, 1*ps * scale);
}

function drawCheese(ox, oy, ps) {
  ctx.fillStyle = C64.yellow;
  ctx.fillRect((ox + 3*ps) * scale, (oy + 2*ps) * scale, 34*ps * scale, 3*ps * scale);
  // Melty drips
  ctx.fillRect((ox + 1*ps) * scale, (oy + 4*ps) * scale, 4*ps * scale, 3*ps * scale);
  ctx.fillRect((ox + 35*ps) * scale, (oy + 4*ps) * scale, 4*ps * scale, 2*ps * scale);
  ctx.fillRect((ox + 16*ps) * scale, (oy + 5*ps) * scale, 3*ps * scale, 2*ps * scale);
}

function drawLettuce(ox, oy, ps) {
  ctx.fillStyle = C64.green;
  ctx.fillRect((ox + 2*ps) * scale, (oy + 2*ps) * scale, 36*ps * scale, 3*ps * scale);
  ctx.fillStyle = C64.lightGreen;
  // Wavy leaf edges
  for (let i = 0; i < 8; i++) {
    const lx = ox + (3 + i * 4) * ps;
    ctx.fillRect(lx * scale, (oy + (i % 2 === 0 ? 1 : 4) * ps) * scale, 3*ps * scale, 2*ps * scale);
  }
}

function drawTomato(ox, oy, ps) {
  ctx.fillStyle = C64.red;
  ctx.fillRect((ox + 3*ps) * scale, (oy + 2*ps) * scale, 34*ps * scale, 3*ps * scale);
  ctx.fillStyle = C64.lightRed;
  ctx.fillRect((ox + 5*ps) * scale, (oy + 3*ps) * scale, 6*ps * scale, 1*ps * scale);
  ctx.fillRect((ox + 15*ps) * scale, (oy + 3*ps) * scale, 6*ps * scale, 1*ps * scale);
  ctx.fillRect((ox + 25*ps) * scale, (oy + 3*ps) * scale, 6*ps * scale, 1*ps * scale);
}

function drawOnion(ox, oy, ps) {
  ctx.fillStyle = C64.lightGrey;
  ctx.fillRect((ox + 4*ps) * scale, (oy + 2*ps) * scale, 32*ps * scale, 2*ps * scale);
  ctx.fillStyle = C64.purple;
  // Onion rings
  for (let i = 0; i < 4; i++) {
    const rx = ox + (6 + i * 8) * ps;
    ctx.fillRect(rx * scale, (oy + 1*ps) * scale, 5*ps * scale, 1*ps * scale);
    ctx.fillRect(rx * scale, (oy + 4*ps) * scale, 5*ps * scale, 1*ps * scale);
    ctx.fillRect((rx - 1*ps) * scale, (oy + 2*ps) * scale, 1*ps * scale, 2*ps * scale);
    ctx.fillRect((rx + 5*ps) * scale, (oy + 2*ps) * scale, 1*ps * scale, 2*ps * scale);
  }
}

// ============================================================
// INPUT
// ============================================================
const keys = {};
let mouseX = W / 2;

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space' || e.code === 'Enter' || e.code.startsWith('Arrow')) e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });
document.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) / scale;
});
document.addEventListener('click', () => { keys['_click'] = true; });
document.addEventListener('touchstart', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = (e.touches[0].clientX - rect.left) / scale;
  keys['_click'] = true;
});
document.addEventListener('touchmove', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = (e.touches[0].clientX - rect.left) / scale;
  e.preventDefault();
}, { passive: false });

function keyPressed(code) {
  if (keys[code]) { keys[code] = false; return true; }
  return false;
}

// ============================================================
// GAME STATE
// ============================================================
let state = 'title';
let stateTime = 0;
let score = 0;
let highScore = parseInt(localStorage.getItem('burgerHS') || '0');
let lives = 3;
let level = 1;
let burgersCompleted = 0;
let totalBurgersForLevel = 3;
let comboCount = 0;

// Current recipe (order of ingredients to assemble)
let recipe = [];
let recipeIndex = 0;
let plateStack = [];

// Falling ingredients
let fallingItems = [];
let spawnTimer = 0;
let spawnInterval = 90; // frames between spawns

// Plate (player controlled)
let plateX = W / 2;
const plateY = 170;
const plateW = 50;

// Particles
let particles = [];

// Conveyor belt items for title screen
let conveyorItems = [];

// Difficulty character (Skate or Die style)
let chefMood = 'happy'; // happy, angry, worried
let chefTimer = 0;

// ============================================================
// RECIPE GENERATION
// ============================================================
function generateRecipe() {
  // Always starts with bottom bun, ends with top bun
  // Middle ingredients vary by level
  const midIngredients = ['patty', 'cheese', 'lettuce', 'tomato', 'onion'];
  recipe = ['bottom_bun'];

  const numMiddle = Math.min(2 + level, 5);
  const shuffled = midIngredients.slice().sort(() => Math.random() - 0.5);
  for (let i = 0; i < numMiddle; i++) {
    recipe.push(shuffled[i]);
  }
  recipe.push('top_bun');
  recipeIndex = 0;
  plateStack = [];
}

// ============================================================
// SPAWNING
// ============================================================
function spawnIngredient() {
  // Decide what to spawn - mix of correct and wrong ingredients
  let key;
  if (Math.random() < 0.5 && recipeIndex < recipe.length) {
    // Spawn the next needed ingredient
    key = recipe[recipeIndex];
  } else {
    // Spawn random ingredient
    const all = INGREDIENTS.map(i => i.key);
    key = all[Math.floor(Math.random() * all.length)];
  }

  const speed = 0.5 + level * 0.15 + Math.random() * 0.3;
  fallingItems.push({
    key: key,
    x: 20 + Math.random() * (W - 60),
    y: -15,
    speed: speed,
    wobble: Math.random() * Math.PI * 2,
    wobbleSpeed: 0.02 + Math.random() * 0.03,
  });
}

// ============================================================
// PARTICLES
// ============================================================
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 3,
      vy: -Math.random() * 2 - 1,
      life: 30 + Math.random() * 20,
      color: color,
      size: 1 + Math.random() * 2,
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.08;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    const alpha = p.life / 50;
    ctx.globalAlpha = Math.min(1, alpha);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x * scale, p.y * scale, p.size * scale, p.size * scale);
  }
  ctx.globalAlpha = 1;
}

// ============================================================
// CHEF CHARACTER (Skate or Die style face)
// ============================================================
function drawChef(x, y, mood) {
  const ps = 2;
  // Hat
  ctx.fillStyle = C64.white;
  ctx.fillRect((x+2*ps)*scale, (y)*scale, 8*ps*scale, 2*ps*scale);
  ctx.fillRect((x+1*ps)*scale, (y+2*ps)*scale, 10*ps*scale, 1*ps*scale);
  // Face
  ctx.fillStyle = C64.orange;
  ctx.fillRect((x+2*ps)*scale, (y+3*ps)*scale, 8*ps*scale, 7*ps*scale);
  // Eyes
  ctx.fillStyle = C64.white;
  ctx.fillRect((x+3*ps)*scale, (y+4*ps)*scale, 2*ps*scale, 2*ps*scale);
  ctx.fillRect((x+7*ps)*scale, (y+4*ps)*scale, 2*ps*scale, 2*ps*scale);
  ctx.fillStyle = C64.blue;
  if (mood === 'happy') {
    ctx.fillRect((x+3*ps)*scale, (y+4*ps)*scale, 1*ps*scale, 1*ps*scale);
    ctx.fillRect((x+7*ps)*scale, (y+4*ps)*scale, 1*ps*scale, 1*ps*scale);
  } else if (mood === 'angry') {
    ctx.fillRect((x+4*ps)*scale, (y+5*ps)*scale, 1*ps*scale, 1*ps*scale);
    ctx.fillRect((x+8*ps)*scale, (y+5*ps)*scale, 1*ps*scale, 1*ps*scale);
    // Angry eyebrows
    ctx.fillStyle = C64.brown;
    ctx.fillRect((x+3*ps)*scale, (y+3*ps)*scale, 2*ps*scale, 1*ps*scale);
    ctx.fillRect((x+7*ps)*scale, (y+3*ps)*scale, 2*ps*scale, 1*ps*scale);
  } else {
    ctx.fillRect((x+3*ps)*scale, (y+5*ps)*scale, 1*ps*scale, 1*ps*scale);
    ctx.fillRect((x+7*ps)*scale, (y+5*ps)*scale, 1*ps*scale, 1*ps*scale);
    // Worried eyebrows
    ctx.fillStyle = C64.brown;
    ctx.fillRect((x+4*ps)*scale, (y+3*ps)*scale, 1*ps*scale, 1*ps*scale);
    ctx.fillRect((x+7*ps)*scale, (y+3*ps)*scale, 1*ps*scale, 1*ps*scale);
  }
  // Mouth
  ctx.fillStyle = mood === 'happy' ? C64.lightRed : (mood === 'angry' ? C64.red : C64.brown);
  if (mood === 'happy') {
    ctx.fillRect((x+4*ps)*scale, (y+8*ps)*scale, 4*ps*scale, 1*ps*scale);
    ctx.fillRect((x+3*ps)*scale, (y+7*ps)*scale, 1*ps*scale, 1*ps*scale);
    ctx.fillRect((x+8*ps)*scale, (y+7*ps)*scale, 1*ps*scale, 1*ps*scale);
  } else if (mood === 'angry') {
    ctx.fillRect((x+4*ps)*scale, (y+7*ps)*scale, 4*ps*scale, 1*ps*scale);
    ctx.fillRect((x+3*ps)*scale, (y+8*ps)*scale, 1*ps*scale, 1*ps*scale);
    ctx.fillRect((x+8*ps)*scale, (y+8*ps)*scale, 1*ps*scale, 1*ps*scale);
  } else {
    ctx.fillRect((x+5*ps)*scale, (y+7*ps)*scale, 2*ps*scale, 2*ps*scale);
  }
  // Mustache
  ctx.fillStyle = C64.brown;
  ctx.fillRect((x+3*ps)*scale, (y+6*ps)*scale, 3*ps*scale, 1*ps*scale);
  ctx.fillRect((x+6*ps)*scale, (y+6*ps)*scale, 3*ps*scale, 1*ps*scale);
}

// ============================================================
// SCANLINE EFFECT
// ============================================================
function drawScanlines() {
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  for (let y = 0; y < H * scale; y += 2 * scale) {
    ctx.fillRect(0, y + scale, W * scale, scale);
  }
}

// ============================================================
// BORDER (C64 style)
// ============================================================
function drawBorder(color) {
  const bw = 4 * scale;
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, W * scale, bw);
  ctx.fillRect(0, H * scale - bw, W * scale, bw);
  ctx.fillRect(0, 0, bw, H * scale);
  ctx.fillRect(W * scale - bw, 0, bw, H * scale);
}

// ============================================================
// TITLE SCREEN (Skate or Die inspired)
// ============================================================
function updateTitle(dt) {
  stateTime += dt;
  // Animate conveyor
  if (conveyorItems.length < 5) {
    const all = INGREDIENTS.map(i => i.key);
    conveyorItems.push({
      key: all[Math.floor(Math.random() * all.length)],
      x: W + 20,
      y: 120 + Math.random() * 10,
    });
  }
  for (let i = conveyorItems.length - 1; i >= 0; i--) {
    conveyorItems[i].x -= 0.5;
    if (conveyorItems[i].x < -50) conveyorItems.splice(i, 1);
  }

  if (keyPressed('Space') || keyPressed('Enter') || keyPressed('_click')) {
    initAudio();
    sfxStart();
    startGame();
  }
}

function drawTitle() {
  // Background
  ctx.fillStyle = C64.blue;
  ctx.fillRect(0, 0, W * scale, H * scale);

  // Animated stripe
  const stripeY = 20;
  ctx.fillStyle = C64.lightBlue;
  ctx.fillRect(0, stripeY * scale, W * scale, 60 * scale);
  ctx.fillStyle = C64.blue;
  ctx.fillRect(0, (stripeY + 2) * scale, W * scale, 56 * scale);

  // Title text with shadow
  drawTextCentered('BURGER', stripeY + 6, C64.black, 3);
  drawTextCentered('BURGER', stripeY + 5, C64.yellow, 3);
  drawTextCentered('ASSEMBLY', stripeY + 26, C64.black, 3);
  drawTextCentered('ASSEMBLY', stripeY + 25, C64.orange, 3);

  // Subtitle
  drawTextCentered('A C64 STYLE GAME', stripeY + 48, C64.cyan, 1);

  // Conveyor belt
  ctx.fillStyle = C64.grey;
  ctx.fillRect(0, 115 * scale, W * scale, 3 * scale);
  ctx.fillRect(0, 138 * scale, W * scale, 3 * scale);
  ctx.fillStyle = C64.darkGrey;
  ctx.fillRect(0, 118 * scale, W * scale, 20 * scale);
  // Conveyor marks
  for (let i = 0; i < 20; i++) {
    const cx = ((i * 20 + stateTime * 30) % (W + 20)) - 10;
    ctx.fillStyle = C64.grey;
    ctx.fillRect(cx * scale, 120 * scale, 2 * scale, 16 * scale);
  }
  // Items on conveyor
  for (const item of conveyorItems) {
    drawIngredient(item.key, item.x, item.y, 1);
  }

  // Chef
  drawChef(20, 88, 'happy');
  // Chef speech
  drawText('ORDER UP!', 50, 95, C64.white, 1);

  // Instructions
  const blink = Math.sin(stateTime * 4) > 0;
  if (blink) {
    drawTextCentered('PRESS SPACE TO START', 152, C64.yellow, 1);
  }

  drawTextCentered('MOVE: ARROW KEYS / MOUSE', 166, C64.lightGrey, 1);
  drawTextCentered('CATCH INGREDIENTS IN ORDER!', 176, C64.lightGrey, 1);

  // High score
  if (highScore > 0) {
    drawTextCentered('HIGH SCORE: ' + highScore, 190, C64.cyan, 1);
  }

  drawBorder(C64.lightBlue);
  drawScanlines();
}

// ============================================================
// GAMEPLAY
// ============================================================
function startGame() {
  state = 'play';
  stateTime = 0;
  score = 0;
  lives = 3;
  level = 1;
  burgersCompleted = 0;
  comboCount = 0;
  fallingItems = [];
  particles = [];
  spawnTimer = 0;
  spawnInterval = 90;
  plateX = W / 2;
  chefMood = 'happy';
  chefTimer = 0;
  generateRecipe();
}

function updatePlay(dt) {
  stateTime += dt;

  // Move plate
  const speed = 3;
  if (keys['ArrowLeft'] || keys['KeyA']) plateX -= speed;
  if (keys['ArrowRight'] || keys['KeyD']) plateX += speed;
  // Mouse control
  const targetX = mouseX;
  plateX += (targetX - plateX) * 0.15;
  plateX = Math.max(25, Math.min(W - 25, plateX));

  // Spawn ingredients
  spawnTimer++;
  if (spawnTimer >= spawnInterval) {
    spawnTimer = 0;
    spawnIngredient();
    // Decrease interval slightly
    spawnInterval = Math.max(30, 90 - level * 8);
  }

  // Update falling items
  for (let i = fallingItems.length - 1; i >= 0; i--) {
    const item = fallingItems[i];
    item.y += item.speed;
    item.wobble += item.wobbleSpeed;
    item.x += Math.sin(item.wobble) * 0.3;

    // Check catch
    const catchZone = plateY - 5 - plateStack.length * 6;
    if (item.y >= catchZone - 2 && item.y <= catchZone + 6) {
      const dx = Math.abs(item.x + ING_W / 2 - plateX);
      if (dx < plateW / 2) {
        // Caught!
        if (item.key === recipe[recipeIndex]) {
          // Correct ingredient!
          plateStack.push(item.key);
          recipeIndex++;
          comboCount++;
          const bonus = 10 * comboCount;
          score += bonus;
          sfxCatch();
          spawnParticles(item.x + ING_W / 2, catchZone, C64.yellow, 8);
          chefMood = 'happy';
          chefTimer = 60;

          // Check if burger complete
          if (recipeIndex >= recipe.length) {
            // Burger complete!
            score += 100 + level * 50;
            burgersCompleted++;
            sfxComplete();
            spawnParticles(plateX, plateY - 20, C64.lightGreen, 20);
            spawnParticles(plateX, plateY - 30, C64.yellow, 15);
            chefMood = 'happy';
            chefTimer = 120;

            if (burgersCompleted >= totalBurgersForLevel) {
              level++;
              burgersCompleted = 0;
              totalBurgersForLevel = 3 + level;
              sfxLevelUp();
            }
            // Start new burger
            setTimeout(() => {
              if (state === 'play') generateRecipe();
            }, 500);
            // Clear falling items briefly
            fallingItems = [];
            break;
          }
        } else {
          // Wrong ingredient!
          comboCount = 0;
          lives--;
          sfxWrong();
          spawnParticles(item.x + ING_W / 2, catchZone, C64.lightRed, 12);
          chefMood = 'angry';
          chefTimer = 90;

          if (lives <= 0) {
            state = 'gameover';
            stateTime = 0;
            sfxGameOver();
            if (score > highScore) {
              highScore = score;
              localStorage.setItem('burgerHS', highScore.toString());
            }
          }
        }
        fallingItems.splice(i, 1);
        continue;
      }
    }

    // Fell off screen
    if (item.y > H + 10) {
      // If it was the needed ingredient, that's a miss
      if (item.key === recipe[recipeIndex]) {
        comboCount = 0;
        chefMood = 'worried';
        chefTimer = 60;
        sfxDrop();
      }
      fallingItems.splice(i, 1);
    }
  }

  // Chef mood timer
  if (chefTimer > 0) {
    chefTimer--;
    if (chefTimer === 0) chefMood = 'happy';
  }

  updateParticles();
}

function drawPlay() {
  // Background - kitchen
  ctx.fillStyle = C64.darkGrey;
  ctx.fillRect(0, 0, W * scale, H * scale);

  // Kitchen back wall
  ctx.fillStyle = '#222244';
  ctx.fillRect(0, 0, W * scale, 30 * scale);
  // Tile pattern
  ctx.fillStyle = '#2a2a4a';
  for (let tx = 0; tx < W; tx += 10) {
    for (let ty = 0; ty < 30; ty += 10) {
      ctx.fillRect((tx + 1) * scale, (ty + 1) * scale, 8 * scale, 8 * scale);
    }
  }

  // Counter / play area
  ctx.fillStyle = C64.black;
  ctx.fillRect(5 * scale, 30 * scale, (W - 10) * scale, (H - 45) * scale);

  // HUD background
  ctx.fillStyle = '#111133';
  ctx.fillRect(5 * scale, 30 * scale, (W - 10) * scale, 12 * scale);

  // Score
  drawText('SCORE:' + score, 8, 33, C64.white, 1);
  // Lives
  drawText('LIVES:', 100, 33, C64.white, 1);
  for (let i = 0; i < lives; i++) {
    ctx.fillStyle = C64.lightRed;
    ctx.fillRect((140 + i * 8) * scale, 33 * scale, 5 * scale, 5 * scale);
  }
  // Level
  drawText('LVL:' + level, 175, 33, C64.cyan, 1);
  // Combo
  if (comboCount > 1) {
    drawText('COMBO X' + comboCount, 220, 33, C64.yellow, 1);
  }

  // Recipe display (right side)
  drawText('ORDER:', 260, 45, C64.white, 1);
  for (let i = 0; i < recipe.length; i++) {
    const ing = INGREDIENTS.find(x => x.key === recipe[i]);
    const done = i < recipeIndex;
    const current = i === recipeIndex;
    const color = done ? C64.green : (current ? C64.yellow : C64.grey);
    const marker = done ? '*' : (current ? '>' : ' ');
    drawText(marker, 260, 53 + i * 7, color, 1);
    drawText(ing.name.substring(0, 9), 268, 53 + i * 7, color, 1);
  }

  // Burger progress on plate
  const burgersText = 'BURGERS: ' + burgersCompleted + '/' + totalBurgersForLevel;
  drawText(burgersText, 260, 140, C64.lightGrey, 1);

  // Chef
  drawChef(265, 150, chefMood);
  // Chef speech bubble
  if (chefMood === 'happy' && chefTimer > 30) {
    drawText('NICE!', 270, 175, C64.lightGreen, 1);
  } else if (chefMood === 'angry') {
    drawText('NO!!', 270, 175, C64.lightRed, 1);
  } else if (chefMood === 'worried') {
    drawText('HURRY!', 270, 175, C64.yellow, 1);
  }

  // Draw plate
  ctx.fillStyle = C64.lightGrey;
  ctx.fillRect((plateX - 22) * scale, plateY * scale, 44 * scale, 3 * scale);
  ctx.fillStyle = C64.white;
  ctx.fillRect((plateX - 20) * scale, (plateY + 1) * scale, 40 * scale, 1 * scale);

  // Draw stacked ingredients on plate
  for (let i = 0; i < plateStack.length; i++) {
    drawIngredient(plateStack[i], plateX - 20, plateY - 8 - i * 6, 1);
  }

  // Draw falling ingredients
  for (const item of fallingItems) {
    drawIngredient(item.key, item.x, item.y, 1);
    // Shadow/label
    const ing = INGREDIENTS.find(x => x.key === item.key);
    if (ing) {
      const needed = item.key === recipe[recipeIndex];
      if (needed) {
        // Highlight needed ingredient
        ctx.strokeStyle = C64.yellow;
        ctx.lineWidth = scale;
        ctx.strokeRect(item.x * scale - scale, item.y * scale - scale, (ING_W + 2) * scale, (ING_H + 2) * scale);
      }
    }
  }

  // Next ingredient indicator
  if (recipeIndex < recipe.length) {
    const nextIng = INGREDIENTS.find(x => x.key === recipe[recipeIndex]);
    drawText('NEED: ' + nextIng.name, 8, 45, C64.yellow, 1);
    drawIngredient(recipe[recipeIndex], 8, 52, 1);
  }

  drawParticles();
  drawBorder(C64.purple);
  drawScanlines();
}

// ============================================================
// GAME OVER SCREEN
// ============================================================
function updateGameOver(dt) {
  stateTime += dt;
  updateParticles();
  if (stateTime > 2 && (keyPressed('Space') || keyPressed('Enter') || keyPressed('_click'))) {
    state = 'title';
    stateTime = 0;
    conveyorItems = [];
  }
}

function drawGameOver() {
  ctx.fillStyle = C64.black;
  ctx.fillRect(0, 0, W * scale, H * scale);

  // Red flashing border
  const flash = Math.sin(stateTime * 5) > 0;
  drawBorder(flash ? C64.red : C64.darkGrey);

  // Sad chef
  drawChef(W / 2 - 12, 30, 'angry');

  // Game Over text
  drawTextCentered('GAME OVER', 60, C64.red, 3);

  drawTextCentered('FINAL SCORE: ' + score, 90, C64.white, 2);
  drawTextCentered('LEVEL REACHED: ' + level, 110, C64.cyan, 1);
  drawTextCentered('BURGERS MADE: ' + burgersCompleted, 120, C64.lightGreen, 1);

  if (score >= highScore && score > 0) {
    const blink = Math.sin(stateTime * 6) > 0;
    if (blink) {
      drawTextCentered('NEW HIGH SCORE!', 135, C64.yellow, 2);
    }
  } else {
    drawTextCentered('HIGH SCORE: ' + highScore, 135, C64.grey, 1);
  }

  // Fallen burger ingredients scattered
  const t = stateTime;
  for (let i = 0; i < 5; i++) {
    const all = INGREDIENTS.map(x => x.key);
    const key = all[i % all.length];
    const bx = 30 + i * 55 + Math.sin(t + i) * 5;
    const by = 155 + Math.cos(t * 0.5 + i * 2) * 3;
    drawIngredient(key, bx, by, 1);
  }

  if (stateTime > 2) {
    const blink = Math.sin(stateTime * 4) > 0;
    if (blink) {
      drawTextCentered('PRESS SPACE TO CONTINUE', 185, C64.lightGrey, 1);
    }
  }

  drawParticles();
  drawScanlines();
}

// ============================================================
// MAIN LOOP
// ============================================================
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  switch (state) {
    case 'title':
      updateTitle(dt);
      drawTitle();
      break;
    case 'play':
      updatePlay(dt);
      drawPlay();
      break;
    case 'gameover':
      updateGameOver(dt);
      drawGameOver();
      break;
  }

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
